// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

// Environment variables for Supabase configuration
// Web uygulamasÄ± iÃ§in optimize edildi
const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
const SUPABASE_PUBLISHABLE_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY;

// Environment variables validation
if (!SUPABASE_URL || !SUPABASE_PUBLISHABLE_KEY) {
  throw new Error('Supabase environment variables are not configured. Please set VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY.');
}

// Force reload environment variables
const envVars = {
  VITE_SUPABASE_URL: import.meta.env.VITE_SUPABASE_URL,
  VITE_SUPABASE_ANON_KEY: import.meta.env.VITE_SUPABASE_ANON_KEY,
  MODE: import.meta.env.MODE,
  DEV: import.meta.env.DEV,
  PROD: import.meta.env.PROD,
};

// Debug iÃ§in API key'i kontrol et (sadece development'ta)
if (import.meta.env.DEV) {
  console.log('ðŸ”‘ Supabase URL:', SUPABASE_URL);
  console.log('ðŸ”‘ Supabase Key Length:', SUPABASE_PUBLISHABLE_KEY?.length || 0);
  console.log('âœ… Web uygulamasÄ± iÃ§in optimize edildi');
}

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: typeof window !== 'undefined' ? localStorage : undefined,
    persistSession: true,
    autoRefreshToken: true,
    flowType: 'pkce',
    detectSessionInUrl: true,
  },
  global: {
    headers: {
      'X-Client-Info': 'budgie-breeding-tracker-web',
      'Cache-Control': 'no-cache',
      'apikey': SUPABASE_PUBLISHABLE_KEY,
      'Content-Type': 'application/json',
    },
    fetch: (url, options = {}) => {
      // Web iÃ§in optimize edilmiÅŸ timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 saniye
      
      // JWT token'Ä± localStorage'dan al
      let authToken = null;
      if (typeof window !== 'undefined') {
        try {
          const supabaseTokens = localStorage.getItem('sb-etkvuonkmmzihsjwbcrl-auth-token');
          if (supabaseTokens) {
            const tokens = JSON.parse(supabaseTokens);
            authToken = tokens.access_token;
          }
        } catch (error) {
          console.warn('JWT token parse hatasÄ±:', error);
        }
      }
      
      const headers = {
        ...options.headers,
        'apikey': SUPABASE_PUBLISHABLE_KEY,
      } as any;

      // JWT token varsa Authorization header'Ä± ekle
      if (authToken) {
        (headers as any)['Authorization'] = `Bearer ${authToken}`;
      }

      // POST/PUT/PATCH istekleri iÃ§in Content-Type'Ä± zorla
      if (options.method && ['POST', 'PUT', 'PATCH'].includes(options.method.toUpperCase())) {
        (headers as any)['Content-Type'] = 'application/json';
      }

      return fetch(url, {
        ...options,
        signal: controller.signal,
        cache: 'no-cache',
        headers,
        mode: 'cors',
        credentials: 'omit',
      }).finally(() => clearTimeout(timeoutId));
    },
  },
  realtime: {
    params: {
      eventsPerSecond: 10,
    },
  },
});

// Timeout wrapper for Supabase operations
export const withTimeout = async <T>(
  promise: Promise<T>,
  timeoutMs: number = 30000
): Promise<T> => {
  const timeoutPromise = new Promise<never>((_, reject) => {
    setTimeout(() => {
      reject(new Error(`Ä°ÅŸlem zaman aÅŸÄ±mÄ±na uÄŸradÄ± (${timeoutMs}ms)`));
    }, timeoutMs);
  });

  return Promise.race([promise, timeoutPromise]);
};

// Retry wrapper for Supabase operations
export const withRetry = async <T>(
  operation: () => Promise<T>,
  maxRetries: number = 3,
  delayMs: number = 1000
): Promise<T> => {
  let lastError: Error;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error as Error;
      console.warn(`Deneme ${attempt}/${maxRetries} baÅŸarÄ±sÄ±z:`, error);
      
      if (attempt === maxRetries) {
        throw lastError;
      }
      
      // Exponential backoff
      const delay = delayMs * Math.pow(2, attempt - 1);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }

  throw lastError!;
};

